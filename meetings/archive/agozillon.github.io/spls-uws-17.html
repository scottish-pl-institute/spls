<!DOCTYPE html>
<html>

<head>
<link rel="stylesheet" type="text/css" href="https://agozillon.github.io/spls-uws-17/CSS/base.css" media="screen" />
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
</head>

<body>
<div class="container">

<div class="row">
<div class="col-lg-9 col-md-7 col-sm-5" style="padding-top: 12px;">
	<h1>Scottish Programming Languages Seminar (SPLS) </h1>
	<h2>University of the West of Scotland, Paisley Campus, 26th June 2017 </h2>
</div>

<div class="col-lg-2 col-md-2 col-sm-2">
	<a href="https://www.uws.ac.uk/home/"><img src="https://agozillon.github.io/spls-uws-17/Images/uwsicon.png" alt="UniIcon"></a>
	<a href="http://www.sicsa.ac.uk/"><img src="https://agozillon.github.io/spls-uws-17/Images/sicsa-logo.jpg" style="margin-left: 10px; width: 8cm;"alt="SicsaIcon"></a>
</div>

</div>

<div class="row col-lg-12 col-md-12 col-sm-12">
<h2 class="text-center">About SPLS</h2>

The <a href="http://www.dcs.gla.ac.uk/research/spls/">Scottish Programming Languages Seminar</a> (SPLS) is a venue for discussion of all aspects of programming languages. This includes theory, implementation and design. SPLS has a long lineage of meetings, going back to 2004. The host of the meeting cycles between several Scottish universities. This is the first time it shall be held at the <a href="https://www.uws.ac.uk/home/">University of the West of Scotland</a>, at its Paisley campus. This upcoming meeting shall be held on the 26th of June. 
</br>
</br>
For further information on SPLS meetings and activites apply to the <a href="https://mr1.dcs.gla.ac.uk/mailman/listinfo/spls">SPLS Mailing List</a>.  

<h2 class="text-center">Time and Location</h2>

This upcoming SPLS meeting will be held at the University of the West of Scotland's Paisley campus, from 12:00 until 17:30. It shall be hosted in the Paisley campus' F Block (also known as Henry Building West). You will be able to get refreshments in room F124 and the talks will be held in room F113. 

</br>
</br> 
Travel information to the campus and the campus map can be found <a href="http://www.uws.ac.uk/about-uws/campuses/paisley/location-and-travel/">here</a>.
</br>
</br> 
If arriving on foot from Paisley Gilmour Street train station, you will first approach the east or north entrance to the campus. For F124 and F113 though, the west entrance will simplify navigation. The Paisley campus' F Block (Henry Building West) is the three storey building in the centre of <a href="https://tinyurl.com/henry-west-uws">this</a> Google Street View image which is taken from the west entrance on Lady Lane. 

<h2 class="text-center"> Registration </h2>

If you could please register using this <a href="https://beta.doodle.com/poll/9u2sinht8xwt3wk8#table">doodle poll</a>, so we can get an idea of numbers for food arrangements.
And if you have any dietary requirements please get in contact with one of the <a href="spls-uws-17#organisers">organisers</a>. 

<h2 class="text-center"> Speakers </h2>

<h5><b>Nick Brown</b> - <i>An implementation of Python for the micro-core Epiphany co-processor</i></h5> 
<h5><b>Christopher Brown</b> - <i>ParaFormance: Democratizing Parallel Software Development</i></h5>
<h5><b>Andrew Gozillon</b> - <i>Programmable address spaces</i></h5> 
<h5><b>Conor McBride</b> - <i>Why walk when you can take the tube?</i></h5>
<h5><b>Michel Steuwer</b> - <i>Towards Composable GPU Programming: Programming GPUs with Eager Actions and Lazy Views</i></h5>
<h5><b>Rob Stewart</b> - <i>Mapping dataflow programs to FPGAs</i></h5>
<h5><b>Thomas Wright</b> - <i>Process algebra meets cellular biology</i></h5> 



<h2 class="text-center">Programme</h2>
<table class="table table-striped">
<thead>
<tr>
<th>Time</th>
<th>Speaker / Affiliation / Title</th>
<th>Abstract</th>
</tr>
<thead>
<tbody>

<tr>
<td class="col-md-1"> 12:00 </td>
<td class="col-md-3"> <div><b>Lunch</b></div><div><b></b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>

<tr>
<td class="col-md-1"> 13:00 </td>
<td class="col-md-3"> <div><b>Conor McBride</b></div><div><b>University of Strathclyde</b></div><div><i>Why walk when you can take the tube?</i></div></td>
<td class="col-md-8" style="font-size:13px">Substituting terms for free variables in terms is a recurrent task in implementations of programming languages and proof assistants. It is not unusual for substitution operations to spend much time searching in vain for free variables in closed subterms. I'll show a way to zip around between the interesting nodes in terms by constructing a "tube network", built from sequences of one-hole contexts. Expect traversable functors, free monads, and a touch of differential calculus.</td>
</tr>

<tr>
<td class="col-md-1"> 13:30 </td> 
<td class="col-md-3"> <div><b>Thomas Wright</b></div><div><b>University of Edinburgh</b></div><div><i>Process algebra meets cellular biology</i></div></td>
<td class="col-md-8" style="font-size:13px">Cells and concurrent programs are not so different - both have to communicate, process information, and respond to their environment. However, biological systems consist of many more agents than even the largest computer networks, and are highly heterogeneous with no apparent overall design, presenting formidable challenges in modelling and understanding their behaviour. Worse still, biologists don't have access to the high level programming languages we rely on in designing concurrent programs, instead working at the level of machine code (DNA) and circuit diagrams (protein signalling networks). This has inspired many to investigate ways to apply ideas from concurrent programming and process algebra to build higher level languages for modelling biochemical systems.
</br>
</br>
We propose a new high level concurrent programming language for modelling biological systems. We build upon the π-calculus, to model cells as communicating agents, and show how concepts such as parallel composition, name binding, and synchronisation correspond to concepts in biology. We apply our language to V. A. Kuznetsov's classic model of immune response to tumour growth, and show how we able capture complex features including by nonlinear interaction dynamics, n-party interactions, and dynamic binding of agents to form new agents.</td>
</tr>

<tr>
<td class="col-md-1"> 14:00 </td>
<td class="col-md-3"> <div><b>Coffee Break</b></div><div><b></b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>

<tr>
<td class="col-md-1"> 14:30 </td> 
<td class="col-md-3"> <div><b>Andrew Gozillon</b></div><div><b>University of the West of Scotland</b></div><div><i>Programmable Address Spaces</i></div></td>
<td class="col-md-8" style="font-size:13px"> In the last decade, high-performance computing has made increasing use of heterogeneous many-core parallelism. Typically the individual processor cores within such a system are radically simpler than their predecessors; and an increased portion of the challenge in executing relevant programs efficiently is reassigned. Tasks, previously the responsibility of hardware, are now delegated to software. Fast, on-chip memory, will primarily be exposed within a series of trivially distinct programming languages, through a handful of address spaces annotations, which associate discrete sections of memory with pointers; or similar low-level abstractions. Traditional CPUs would provide a hardware data cache for such functionality. Our work aims to improve the programmability of address spaces by exposing new functionality within the existing template metaprogramming system of C++. This is achieved firstly via a new LLVM attribute, ext_address_space which facilitates integration with the non-type template parameters of C++. We also present a type traits API which encapsulates the address space annotations, to allow execution on both conventional and extended C++ compilers.</td>
</tr>

<tr>
<td class="col-md-1"> 15:00 </td>
<td class="col-md-3"> <div><b>Christopher Brown</b></div><div><b>University of St Andrews</b></div><div><i>ParaFormance: Democratizing Parallel Software Development</i></div></td>
<td class="col-md-8" style="font-size:13px"> 
Emerging multicore and manycore architectures offer major advantages in terms of performance and low energy usage. We are already seeing designs for 100+ cores CPUs and 1000+ cores GPUs, offering significant potential for parallelism. However, programming models are lagging behind. Exploiting the potential of new parallel systems, even using higher-level programming models, is highly challenging.
</br>
</br>
Fundamentally:
"Parallelism is too hard for programmers today"
</br>
Bjarne Stroustrup, Inventor of C++
</br>
</br>
ParaFormance is a novel software toolset for C and C++ that allows software developers to optimise systems for performance and energy consumption by exploiting parallelism quickly and easy. Our ParaFormance tool discovers the potential areas in the application for parallelism, refactors it to introduce the parallel business logic automatically and checks it for thread-safety and runtime bugs. Our case studies have shown 2.5 million lines of code analysed and refactored using ParaFormance, that’s 1 month of manual effort reduced to around 5 minutes. In this talk I will introduce the ParaFormance toolset and give a demonstration of it on a realistic use-case.</td>
</tr>

<tr>
<td class="col-md-1"> 15:30 </td> 
<td class="col-md-3"> <div><b>Michel Steuwer</b></div><div><b>University of Edinburgh</b></div><div><i>Towards Composable GPU Programming: Programming GPUs with Eager Actions and Lazy Views</i></div></td>
<td class="col-md-8" style="font-size:13px"> In this work, we advocate a composable approach to programming  systems with Graphics Processing Units (GPU): programs are developed as compositions of generic, reusable patterns. Current GPU programming approaches either rely on low-level, monolithic code without patterns (CUDA and OpenCL), which achieves
high performance at the cost of cumbersome and error-prone programming, or
they improve the programmability by using pattern-based abstractions (e.g.,
Thrust) but pay a performance penalty due to inefficient implementations of
pattern composition.
</br>
</br>
We develop an API for GPUs based programming on C++ with STL-style patterns
and its compiler-based implementation. Our API gives the application developers
the native C++ means (views and actions) to specify precisely which pattern
compositions should be automatically fused during code generation into a single
efficient GPU kernel, thereby ensuring a high target performance. We implement
our approach by extending the range-v3 library which is currently being developed
for the forthcoming C++ standards. The composable programming in our approach
is done exclusively in the standard C++14, with STL algorithms used as patterns
which we re-implemented in parallel for GPU. Our compiler implementation is
based on the LLVM and Clang frameworks, and we use advanced multi-stage
programming techniques for aggressive runtime optimizations.
</br>
</br>
We experimentally evaluate our approach using a set of benchmark applications and
a real-world case study from the area of image processing. Our codes achieve
performance competitive with CUDA monolithic implementations, and we
outperform pattern-based codes written using Nvidia’s Thrust.</td>
</tr>

<tr>
<td class="col-md-1"> 16:00 </td>
<td class="col-md-3"> <div><b>Coffee Break</b></div><div><b></b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>

<tr>
<td class="col-md-1"> 16:30 </td>
<td class="col-md-3"> <div><b>Nick Brown</b></div><div><b>EPCC, University of Edinburgh</b></div><div><i>An implementation of Python for the micro-core Epiphany co-processor</i></div></td>
<td class="col-md-8" style="font-size:13px"> The Epiphany is a many-core, low power, low on-chip memory co-processor typical of a number of innovative micro-core architectures. The very low power nature of these architectures means that there is potential for their use in future HPC machines, and their low cost makes them ideal for HPC education & prototyping. However there is a high barrier to entry in programming due to the associated complexities and immaturity of supporting tools.</td>
</tr>


<tr>
<td class="col-md-1"> 17:00 </td> 
<td class="col-md-3"> <div><b>Rob Stewart</b></div><div><b>Heriot-Watt University</b></div><div><i>Mapping dataflow programs to FPGAs</i></div></td>
<td class="col-md-8" style="font-size:13px"> 
FPGAs are unlike fixed, conventional processor architectures. FPGAs are programmable, meaning that logic gates and special purpose hardware blocks can be configured to precisely meet the needs of algorithms. Dataflow languages map naturally to the distributed hardware layout on FPGA fabric, and offer a high level programming abstraction to design FPGA accelerators.
</br>
</br>
This talk will cover dataflow language models, from synchronous actors supporting signal processing, to asynchronous FSM actors supporting complex non-trivial algorithms. I will demonstrate how a hardware cost modeller is used in conjunction with a graphical program refactoring tool we have developed, to trade off throughput time with space. Our Petri Net dataflow abstraction aids parallelism discovery of stateful actors, to increase the generality of the program transformations. I will briefly present our image processing DSL, showing how the Dataflow Process Network model is an effective intermediary between higher order
algorithm skeletons and FPGAs.
</td>
</tr>

<tr>
<td class="col-md-1"> 17:30 </td>
<td class="col-md-3"> <div><b>End</b></div><div><b></b></div><div><i></i></div></td>
<td class="col-md-8"> </td>
</tr>

</tbody>
</table>

<h2 class="text-center">Acknowledgement</h2>

This meeting of SPLS has been supported by the <a href="http://www.sicsa.ac.uk/research/theory-modelling-computation/">Theory, Modelling and Computation</a> theme of the <a href="http://www.sicsa.ac.uk/">Scottish Informatics and Computer Science Alliance (SICSA).</a> 

<h2 class="text-center"> Organisers </h2> <a name="organisers"></a>

Paul Keir, <a href="mailto:Paul.Keir@uws.ac.uk">Paul.Keir@uws.ac.uk</a> 
</br>
Andrew Gozillon, <a href="mailto:Andrew.Gozillon@uws.ac.uk">Andrew.Gozillon@uws.ac.uk</a> 
</div>
</div>
<div style="height:25px"></div>
</body>

</html>
